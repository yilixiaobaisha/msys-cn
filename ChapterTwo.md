# 教程辅导 #

如果您对教程中的任何地方存在任何疑惑、或者问题，请加入我们的QQ群寻求帮助：804824578

# 1、前言 #

对于开发操作系统的环境，没有比UNIX工作环境更加理想的了，我们只需要一个控制台、一套编译器和一台调试用的设备。在过去，操作系统开发工作好比黑箱作业，我们只能凭感觉写出来代码，用编译器编译成为机器二进制之后，用特殊的设备写入目标机器（在嵌入式开发上使用编程器实现设备的写入），在这之后，就只能打开调试机器的电源，等待着结果的出现，毫无办法观察代码到底是如何实现执行的。

在1990年代，逐渐的萌生了基于源代码的调试技术，现实中的例子如Windows上的Visual C++集成开发环境里的源代码调试，还有Linux操作系统上的gdb控制台调试工具和insight源代码级别调试工具。源代码级别的调试工具极大程度上提升了程序开发中除错的能力，因此现代的操作系统和应用程序才有这么稳定的性能，记得当年使用Windows 95的时候，很容易就会发生蓝屏死机现象，这都是由于代码在开发的过程中不能得到有效的测试和除错的结果。

在本系列OS开发文章中，我将介绍多年以来结合我从www.oldlinux.org网站上利用虚拟机对linux早期内核进行调试的方法，发现的新的基于虚拟机的内核调试开发环境，在本环境中我们将使用insight调试器配合qemu虚拟机的特有功能实现对内和的完全源代码级别调试，让内核开发如应用程序的开发一般简单。

集成开发环境是现代开发环境的一部分，但是相比基于命令的控制台开发环境，其有一定的限制：
  1. 通过基于命令行的调试环境，可以很容易的实现各种工具的调用，而操作系统开发中充满了各种各样工具调用过程的组合；
  1. 实际的IDE中虽然对各种工具有可配置的选项，但是对于OS开发来说，许多选项是编译器特有的，只有通过命令行才能有效的控制编译参数；
  1. IDE虽然一键就可以实现代码的编译，但是我们所面对的只是代码和最终的成果，其中隐藏了过多的代码编译的细节让我们不知道哪里潜在出现问题；

因此，在本系列文章中，我们将在Windows平台上使用MSYS开发环境进行开发。

# 2、开发环境的安装 #

MSYS是本人目前维护的一个面向国内用户的开源项目，其中移植了一个完整的Linux工作环境，包含gcc编译器、gdb调试器、insight、qemu虚拟机、完整的UNIX控制台命令集等一系列操作系统开发所需要的必备工具。在MSYS平台上，其中的gcc是基于MINGW版本的移植，其中所附带的标准库完整的实现了Windows API，参照MSDN手册可以毫无顾虑的实现各种目的Windows编程，我本人通过对MSDN手册的探索已经成功的基于MSYS平台实现了控制台程序、Windows窗体程序（需要安装resedit包，用于图形界面的绘制）、Windows动态链接库（dll）、DirectX9 三维游戏的开发、甚至Windows WDM设备驱动的开发。在本篇文章中，我将深入浅出带领大家对MSYS中的各种工具进行使用介绍，以备后面的具体OS开发内容做铺垫和准备，如果大家感兴趣MSYS环境的其他应用，请您参考以后我将发布的其他系列的博客文章。
首先这里提供一下MSYS的下载地址：

> http://msys-cn.googlecode.com

安装过程请参照项目主页中的说明，其中已经尽量做到了详细，但是在这里为了我们的OS开发，安装过程中必须安装如下的几个附加包：
  1. 首先，更新包是必不可少的；
  1. insight包，这是我们后面用于配合qemu虚拟机的源代码级调试；
  1. 安装qemu包，这是我们的虚拟机，将模拟我们开发的目标机器执行代码和实现调试；
  1. 我们选择使用GCC 4编译器，这是因为这个GCC 4版本生成代码性能高而且调试速度快；

所以下载了MSYS基础包之后，首先将mingw4下载下来，将MSYS解压到任意路径（路径中任何文件夹不许有中文或者空格），然后打开mingw.7z压缩包，把里面的mingw目录拖动到解压出来的bin、etc等同级的目录中即可实现完整安装。然后运行MSYS，系统将进行一些初始化，然后会自动在MSYS目录下创建home目录，如果您熟悉Linux的目录结构，相信你不会陌生，MSYS目录就是我们传说中的根目录。下面执行如下的命令：
```
mpkg --install update-1
mpkg --install insight
mpkg --install qemu
```

如果没有发生错误，那么我们的安装就已经成功了，如果还需要其他的包，请您具体参考主页上的说明进行安装，记住安装完成后，需要重新启动MSYS，也就是关掉然后再打开msys.bat，才能使用新安装的包。

为了更方便的使用MSYS，可以将msys.bat创建快捷方式在桌面上，设置其图标为MSYS\bin\rxvt.exe所用的。

# 3、MSYS环境下的HelloWorld #

当我们启动MSYS之后，初始化完毕后会显示一个命令提示符，在这里我们就可以开始工作了。首先我们需要知道，MSYS环境不仅仅是一个开发环境，其实际上是完整的UNIX/Linux控制台环境，可以实现系统管理、文件操作、网络登陆、文本创建等等多种功能，而我们在这里只介绍其在程序开发上面的用途。
MSYS实际上就是基于一个在Windows上移植的UNIX环境标准C/C++库而实现的，因此由于这些工具的开发者都是老外，我们不可能期待它全部以中文来显示出错或提示信息。下面我们以创建世界上唯一最完美、也最著名的hello world程序开始我们的教程：

在所有代码之前，读者需要明白，以下（包含以后文章）中的注释仅供读者能够弄懂这些代码的作用而写入，希望读者在输入这些代码的过程中忽略这些注释，如果输入可能造成潜在的程序无法编译。

首先第一步，打开MSYS环境，按照Linux上的习惯，我们一登陆会默认进入我们自己的主目录HOME，一般位于Windows文件系统的 MSYS\home\“你的Windows用户名" 目录下面。MSYS环境实际上是以MSYS目录虚拟为系统的根目录，然后其上的文件结构都在根上面衍生而出，作为新手我们很容易在目录切换中迷失，而且这是一个控制台的目录结构，不能通过视觉有效的看出有哪些内容，那么每当迷失的时候，请记得输入如下命令，就会弹出当前目录的Windows目录浏览窗口，这样你就可以用Windows窗口来观察当前目录的结构了：
```
explorer .
```

而在MSYS环境中，我们常用如下几条命令来进行目录的查看与操作：
```
# 注意：Windows文件系统一般用正斜杠'\'表示目录结构，而UNIX用反斜杠'/'表示目录结构。

# 目录显示：
ls                 # 显示当前目录内容
ls ..              # 显示上一级目录的内容
ls /mingw          # 显示根目录下mingw目录中的内容

# 目录转换：
cd ..              # 返回上一级目录
cd .               # 单个点，代表进入本目录（自己）
cd abc             # 进入名叫abc的目录
cd /mingw          # 进入根目录下名叫mingw的目录
cd /d/msys         # 进入系统D盘下的msys目录（MSYS特有）

# 创建、删除目录
mkdir abc          # 创建一个名叫abc的目录
rmdir abc          # 删除名叫abc的目录，但是如果abc内有文件，则不能删除

# 创建、删除文件
touch def          # 创建一个名叫def的空文件，如果def存在，则更新其改动时间
rm    def          # 删除名叫def的文件

# 编辑新文件，我们使用vim编辑器
vi test.c          # 编辑一个名叫test.c的C语言源代码文件，保存则写入
```

对于VIM编辑器，这是一个有模式编辑器（Modal），因此一般新手会感觉很难使用，在这里我先对VIM我们常用到的功能进行介绍。在我们刚启动VIM编辑器时，我们会发现无论我们输入什么，都无法写入文件内容，这是因为刚启动时VIM还处于’浏览与命令模式‘，任何时候按下ESC键，就可以返回最开始的‘浏览与命令模式’，下面我对该模式的一些常用命令进行介绍：

首先，强烈推荐读者研究一下下面这一幅VIM编辑器的键盘指法表：

![http://msys-cn.googlecode.com/files/o_vim.png](http://msys-cn.googlecode.com/files/o_vim.png)

然后我们开始熟悉各种命令的简单使用方法：

```
在文件内移动：

i, k, j, l       分别对应于‘上’，‘下’，‘左’，‘右’
i                在当前光标位置进入'编辑模式'
o                在当前光标行之下创建一个新行并进入'编辑模式'
O                大写O，在当前光标行之上添加新行并进入'编辑模式'
p                在当前光标位置以下粘贴剪切或刚删除的内容（删除自动进入剪贴板）
P                在当前光标位置以上粘贴剪切或刚删除的内容
dd               删除当前光标所在的行
dw               删除当前光标所在的词
d$               从当前光标位置一直删除到行末
HOME、END        跳到本行头部，跳到本行尾部
PgUP、PgDn       向上、向下翻页
DELETE           删除当前光标下的字
v                进入可视化选择模式，用ikjl进行光标的移动，然后可以复制、删除
```

在‘浏览与命令模式’下我们输入英文冒号’:'，就进入了VIM的’功能命令模式‘，可以在最下面一行输入VIM特有的命令，这些命令可以实现对文件的各种操作，比如写入、退出VIM、寻求帮助等等，在这个模式下有如下的常用命令：
```
:w           保存文件
:wa          保存所有正在编辑的文件
:q           退出VIM
:help        进入帮助
```

当然，您还可以简单的的敲入
```
:wqa         也就是以上几个命令的组合
```

以上是我们对VIM进行的简单介绍，如果您需要更深入的彻底学习VIM，我给您推荐一本非常不错的VIM中文教程：
> http://edt1023.sayya.org/vim/vim.pdf

下面我们来利用以上所学的东西完成我们的第一个’Hello world‘程序：

首先，我们需要回到主目录：
```
cd ~          # UNIX系统中，~代表自己的主目录
```

然后，我们创建名叫hello的目录来包含我们的新项目，在其中用VIM编辑一个名叫hello.c的C语言源代码：
```
mkdir hello   # 创建名叫hello的目录
vim hello.c   # 用vim编辑名叫hello.c的文件
```

在vim中，我们先用’i‘进入编辑模式，然后写入如下代码：
```
#include <stdio.h>
 
int main(void)
{
    printf("hello world!\n");
    return 0;
}
```

下面我们按下ESC键，返回’浏览与命令模式‘，然后按下':wq’保存和退出VIM，现在我们又返回了控制台，现在我们开始编译代码：
```
gcc hello.c -o hello.exe  # 用gcc编译器编译hello.c，生成hello.exe程序
```

这样我们就从名叫hello.c的源代码，生成了名叫hello.exe的应用程序，这就是一个最简单的应用程序的开发过程，在以后的开发中，我们的所有程序都需要经历这样的三个步骤。下面我们再介绍一下MSYS环境下，应用程序基于insight调试器的源代码级别调试：

gcc编译器有一个编译选项'-g'能够使得输出的应用程序可以被源代码级别调试，因此我们需要用如下的命令重新编译hello.c文件：
```
gcc -g hello.c -o hello.exe  # 在exe内加上gdb可用的调试信息
```

然后在MSYS中输入如下的命令，用insight调试器来加载hello.exe，并对其进行执行时调试：
```
insight hello.exe
```

输入命令后，会弹出一个图形化的调试界面，这个界面与MSVC中的调试模式结构非常类似，因此熟悉的用户可以很方便的进行‘单步’、‘步过’对代码的执行进行控制，如果您需要对insight的使用进行深入了解，请您google相关的信息。

调试界面出现后，我们会发现控制台不能再输入命令了，这是因为UNIX环境中，当前被执行的程序不退出是无法执行下一个程序的，但是UNIX环境提供了将程序后台执行，以便继续执行其他命令的方式，需要用如下的方式调用insight调试器：
```
insight hello.exe &   # &符号必须在行尾，说明让任务在后台执行，所有命令通用
```

很多时候，我们需要编写多个程序文件，以方便对日益增长的代码量进行有效的管理，下面我们对hello world程序进行修改，以便以后的扩展，我们在另外一个文件中实现hello world的打印，用vim编辑一个叫做test.c的文件，并输入以下内容并保存：
```
#include <stdio.h>
#include "test.h"

int test(char *str)
{
    printf("%s\n", str);
    return 0;
}
```

通常，为了方便说明一个代码中包含了哪些可以被调用的函数，或者可以被操作的数据，我们需要编写一个头文件作为介面定义，让其他代码可以访问该文件中的函数或者变量，通常取与被描述的代码相同的名字，我们这里取其名字为test.h，用vim编辑如下文件并保存：
```
#ifndef __TEST_H__          // 如果未定义该宏，则定义出来，防止多次被include
#define __TEST_H__

// 这里开始写对test.c的内容的描述，我们只有test函数，因此
extern int test(char *str); // 注意结尾必须有分号，extern后重新输入一遍定义

#endif
```

下面，我们需要修改我们的hello.c中的主函数，通过调用test函数实现hello world的打印：
```
#include "test.h"                 // 包含我们对test.c的介面定义

int main(void)
{
    test("Hello World, MSYS !");  // 调用我们自己的test函数实现打印
    return 0;
}
```

下面我们在控制台中对新的代码进行编译，本次编译我们需要了解更多的新知识，往往我们在使用VC开发环境进行代码开发的时候，每当我们输入一个新的代码，只需要按下一个编译执行的按钮，就实现了整个的编译过程并执行了生成的可执行文件，这个过程中隐藏了太多我们需要实际了解的知识。

传统中，我们知道C语言可以被机器执行，但是到底是如何执行的却并不清楚，实际上在一次编译过程中，需要经历如下的过程，我们不可避免的问题是处理器只能执行与汇编相对应的机器码：
```
“C/C++语言源代码" --(C/C++语言编译器)--> ”汇编代码" --(汇编器as)--> "二进制目标代码" --(链接器ld)--> “可执行程序"
```

其中每一个步骤都有一些可以附加选择优化，在集成开发环境中，我们很难对每一步的具体实现进行控制，因为这一切都是被风装在图形环境的程序之中的。下面我们来用控制台体验一遍完全可控的编译过程：

首先我们需要用高级语言编译器把C语言转换为汇编代码：
```
gcc -S hello.c -o hello.s
gcc -S test.c -o test.s
```

到了这里，我们可以尝试用vim编辑器打开生成的‘.s’代码，看看具体C语言编译器做了哪些工作，这些生成的汇编代码中就是通过对C语言描述而形成的汇编码，当然，许多程序高手如今仍然鄙视这些自动生成的代码的效率低下，而仍然在继续用汇编语言编写高效、简洁的纯汇编应用程序。

最早C语言编译器被设计出来之初，只是一个用于自动生成汇编代码的宏工具，当时自动生成的汇编码执行效率低下，相应的优化理论也并不完善，但是如今高级语言编译器基本上都支持各种优化，一般情况下包含两次优化：
  1. 将C/C++语法扫描形成一个树形结构，对其进行逻辑上的化简，然后生成初步的汇编码
  1. 基于汇编码进行模拟执行优化，提出各种执行路线，然后根据每条指令执行所需要的处理器时间求和，根据用户需要，取其中速度最快（时间优化）或者尺寸最小（尺寸优化）的作为输出。

实际上在计算机中，我们不可能避免的一个矛盾就是，我们要么获得较小的尺寸而损失执行速度，要么获得较高的执行速度而消耗更大的存储空间，但是对于如今海量存储的计算机来说，很多时候我们并不需要考虑尺寸问题。

GCC编译器支持三种级别的优化，通过 '-O1'（尺寸优化），'-O2'（速度优化），'-O3'（综合优化）进行指定，比如下面的调用例子：
```
gcc -O2 -S hello.c -o hello.s
gcc -O2 -S test.c -o test.s
```

下面我们将这些汇编码编译生成二进制目标码：
```
as hello.s -o hello.o
as test.s -o test.o
```

通常情况下我们如果不需要检查或者潜在的通过修改而优化汇编代码的话，可以跳过汇编的生成阶段而直接用gcc生成目标代码：
```
gcc -c hello.c -o hello.o
gcc -c test.c -o test.o
```

然后我们需要进行链接过程，将两个源代码生成的目标代码链接成一个，再加上一些操作系统启动一个应用程序所必需的首先执行的初始化机器码（一般包含在标准库/mingw/lib目录之下，/mingw/include是标准头文件的命令，比如stdio.h就是存储在那里），才能生成一个完整的应用程序，而使用ld直接手工链接，我们通常很难记住那些操作系统所需要的库的名字，我们一般用gcc命令自动实现链接：
```
gcc hello.o test.o -o hello.exe
```

然而，GCC命令也可以一次性完成整个从代码到应用程序的过程：
```
gcc hello.c test.c -o hello.exe
```

或者，加上速度优化：
```
gcc -O2 hello.c test.c -o hello.exe
```

很多时候我们可能会创建许多个代码文件，甚至多个包含代码的目录，在这么多代码的情况下我们不可能手工的编译所有的内容，所以我们就需要用make来实现项目的管理，下面我们编写一个简单的Makefile来结束本篇的旅程：

make，是UNIX环境上最常用的项目管理工具，执行该命令后make会自动在当前目录下搜寻名叫Makefile的文件，然后通过读取其中的信息实现各种代码的编译，一个用户我们的hello world项目的Makefile按照如下方式编写：
```
# 配置工具链
AS=as     # 汇编器
CC=gcc    # C编译器
LD=gcc    # 链接器

# 配置工具链的调用参数
ASFLAGS=-g
CCFLAGS=-g
LDFLAGS=

# 我们目标，可用'\'换行
OBJECT=hello.o \
       test.o
TARGET=hello.exe

# 如何编译各种目标的过程

# 默认目标（make 不带目标对象，或者make all）
all: $(TARGET)

$(TARGET) : $(OBJECT)
    $(LD) $(OBJECT) -o $(TARGET) $(LDFLAGS)

# 指定从.c文件生成.o文件的方法，$@代表输出文件，$<代表输入文件
%.o : %.c
    $(CC) $(CCFLAGS) -c -o $@ $<

%.o : %.s
    $(AS) $(ASFLAGS) -o $@ $<
```

很多朋友可能期待了解更多关于项目管理工具make的更多细节或者教程，通过浏览网上各种中文Makefile教程版本，我推荐大家阅读这篇文章，本人就不班门弄斧的详解Makefile的结构了，当然大家如果有疑问可以跟我交流讨论:)

> http://www.itpub.net/219475.html

这样，我们就完成了一个完整的MSYS环境下的代码项目，其中包含源代码、Makefile的创建、调试工具的使用和应用程序的生成。在以后的篇章里，我们先不着急开始OS开发，我将对MSYS环境中更多的有用工具进行介绍，以便大家能够在今后的使用中更多的使用这些工具来简化开发过程。